{"version":3,"file":"chat_component.min.js","sources":["../src/chat_component.js"],"sourcesContent":["import {BaseComponent} from 'core/reactive';\nimport Templates from 'core/templates';\nimport * as helper from 'block_ai_chat/helper';\n\nclass ChatComponent extends BaseComponent {\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        // This is an optional name for the debugging messages.\n        this.name = 'ChatComponent';\n        // We will always define our component HTML selectors and classes this way so we only define\n        // once and we don't contaminate our logic with tags and other stuff.\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            PERSONABANNER: `[data-block_ai_chat-element='personabanner']`,\n            PERSONA_SELECT_DROPDOWN: `[data-block_ai_chat-element='personaselectdropdown']`,\n            INPUT_TEXTAREA: `[data-block_ai_chat-element='inputtextarea']`,\n            SUBMIT_BUTTON: `[data-block_ai_chat-element='submitbutton']`,\n        };/*\n        this.classes = {\n            BITTEN: `bitten`,\n        };*/\n        // If you need local attributes like ids os something it should be initialized here.\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Note in this case we want our stateReady to be async.\n     *\n     * @param {object} state the initial state\n     */\n    stateReady(state) {\n\n        console.log(state)\n        const personaDropdownContainer = this.getElement(this.selectors.PERSONA_SELECT_DROPDOWN);\n        this.reactive.state.personas.forEach((persona) => {\n            const optionElement = document.createElement('option');\n            optionElement.value = persona.id;\n            optionElement.text = persona.name;\n            personaDropdownContainer.appendChild(optionElement);\n        });\n        const personaBanner = this.getElement(this.selectors.PERSONABANNER);\n        personaBanner.innerText = `${this.reactive.state.personas.get(state.config.currentPersona).userinfo}`;\n        this.addEventListener(\n            this.getElement(this.selectors.PERSONA_SELECT_DROPDOWN),\n            'change',\n            this._selectCurrentPersonaListener\n        );\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        console.log(textarea)\n        const sendRequestButton = this.getElement(this.selectors.SUBMIT_BUTTON);\n        sendRequestButton.addEventListener('click', this._submitAiRequestListener.bind(this));\n        this._refreshPersona({element: state.config});\n    }\n\n    /**\n     * We want to update the person every time something in its state change. To do this we need\n     * to define a watcher.\n     *\n     * @returns {Array} of watchers\n     */\n    getWatchers() {\n        return [\n            {watch: `messages:created`, handler: this._renderMessageToChatArea},\n            {watch: `config.currentPersona:updated`, handler: this._refreshPersona},\n        ];\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    async _renderMessageToChatArea({element}) {\n        // We have a convenience method to locate elements inside the component.\n        console.log('MESSAGES WERDEN GERENDERT')\n        console.log(element);\n        // TODO Filter messages that do not belong to the current conversation\n\n        const templateData = {\n            id: element.id,\n            senderai: element.sender === 'ai',\n            content: element.content\n        };\n        const {html, js} = await Templates.renderForPromise('block_ai_chat/message', templateData);\n        Templates.appendNodeContents('.block_ai_chat-output', html, js);\n\n        // Add copy listener for question and reply.\n        helper.attachCopyListenerLast();\n\n        // Scroll the modal content to the bottom.\n        helper.scrollToBottom();\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    _refreshPersona({element}) {\n        // We have a convenience method to locate elements inside the component.\n        const newPersonaId = element.currentPersona;\n        console.log(newPersonaId);\n        console.log('PERSONA WIRD REFRESHED')\n        console.log(this.getElement(this.selectors.PERSONABANNER))\n        this.getElement(this.selectors.PERSONABANNER).innerText = `${this.reactive.state.personas.get(newPersonaId).userinfo}`;\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n\n    _putPersonaListener() {\n        // We don't want to submit the form.\n        event.preventDefault();\n        // Get the selected person id.\n        console.log('Firing the event')\n        const persona = {\n            userid: 0,\n            name: \"new name\",\n            prompt: \"New prompt\",\n            userinfo: \"Das ist eine neue persona\",\n        };\n        this.reactive.dispatch('putPersona', 21, persona);\n    }\n\n    _selectCurrentPersonaListener() {\n        event.preventDefault();\n        this.reactive.dispatch('selectCurrentPersona', this.reactive.state.static.contextid, event.target.value);\n    }\n\n    _submitAiRequestListener() {\n        event.preventDefault();\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const prompt = textarea.value;\n        this.reactive.dispatch('submitAiRequest', prompt);\n    }\n}\n\nexport default ChatComponent;"],"names":["ChatComponent","BaseComponent","create","name","selectors","MESSAGES","PERSONABANNER","PERSONA_SELECT_DROPDOWN","INPUT_TEXTAREA","SUBMIT_BUTTON","stateReady","state","console","log","personaDropdownContainer","this","getElement","reactive","personas","forEach","persona","optionElement","document","createElement","value","id","text","appendChild","innerText","get","config","currentPersona","userinfo","addEventListener","_selectCurrentPersonaListener","textarea","_submitAiRequestListener","bind","_refreshPersona","element","getWatchers","watch","handler","_renderMessageToChatArea","templateData","senderai","sender","content","html","js","Templates","renderForPromise","appendNodeContents","helper","attachCopyListenerLast","scrollToBottom","newPersonaId","_putPersonaListener","event","preventDefault","dispatch","userid","prompt","static","contextid","target"],"mappings":"quCAIMA,sBAAsBC,wBAQxBC,cAESC,KAAO,qBAGPC,UAAY,CACbC,mDACAC,6DACAC,+EACAC,8DACAC,6DAeRC,WAAWC,OAEPC,QAAQC,IAAIF,aACNG,yBAA2BC,KAAKC,WAAWD,KAAKX,UAAUG,8BAC3DU,SAASN,MAAMO,SAASC,SAASC,gBAC5BC,cAAgBC,SAASC,cAAc,UAC7CF,cAAcG,MAAQJ,QAAQK,GAC9BJ,cAAcK,KAAON,QAAQjB,KAC7BW,yBAAyBa,YAAYN,kBAEnBN,KAAKC,WAAWD,KAAKX,UAAUE,eACvCsB,oBAAeb,KAAKE,SAASN,MAAMO,SAASW,IAAIlB,MAAMmB,OAAOC,gBAAgBC,eACtFC,iBACDlB,KAAKC,WAAWD,KAAKX,UAAUG,yBAC/B,SACAQ,KAAKmB,qCAEHC,SAAWpB,KAAKC,WAAWD,KAAKX,UAAUI,gBAChDI,QAAQC,IAAIsB,UACcpB,KAAKC,WAAWD,KAAKX,UAAUK,eACvCwB,iBAAiB,QAASlB,KAAKqB,yBAAyBC,KAAKtB,YAC1EuB,gBAAgB,CAACC,QAAS5B,MAAMmB,SASzCU,oBACW,CACH,CAACC,yBAA2BC,QAAS3B,KAAK4B,0BAC1C,CAACF,sCAAwCC,QAAS3B,KAAKuB,2DAahCC,QAACA,cAE5B3B,QAAQC,IAAI,6BACZD,QAAQC,IAAI0B,eAGNK,aAAe,CACjBnB,GAAIc,QAAQd,GACZoB,SAA6B,OAAnBN,QAAQO,OAClBC,QAASR,QAAQQ,UAEfC,KAACA,KAADC,GAAOA,UAAYC,mBAAUC,iBAAiB,wBAAyBP,iCACnEQ,mBAAmB,wBAAyBJ,KAAMC,IAG5DI,OAAOC,yBAGPD,OAAOE,iBAaXjB,2BAAgBC,QAACA,qBAEPiB,aAAejB,QAAQR,eAC7BnB,QAAQC,IAAI2C,cACZ5C,QAAQC,IAAI,0BACZD,QAAQC,IAAIE,KAAKC,WAAWD,KAAKX,UAAUE,qBACtCU,WAAWD,KAAKX,UAAUE,eAAesB,oBAAeb,KAAKE,SAASN,MAAMO,SAASW,IAAI2B,cAAcxB,UAKhHyB,sBAEIC,MAAMC,iBAEN/C,QAAQC,IAAI,yBAOPI,SAAS2C,SAAS,aAAc,GANrB,CACZC,OAAQ,EACR1D,KAAM,WACN2D,OAAQ,aACR9B,SAAU,8BAKlBE,gCACIwB,MAAMC,sBACD1C,SAAS2C,SAAS,uBAAwB7C,KAAKE,SAASN,MAAMoD,OAAOC,UAAWN,MAAMO,OAAOzC,OAGtGY,2BACIsB,MAAMC,uBAEAG,OADW/C,KAAKC,WAAWD,KAAKX,UAAUI,gBACxBgB,WACnBP,SAAS2C,SAAS,kBAAmBE,sBAInC9D"}