{"version":3,"file":"chat_component.min.js","sources":["../src/chat_component.js"],"sourcesContent":["import {BaseComponent} from 'core/reactive';\n\nclass ChatComponent extends BaseComponent {\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        // This is an optional name for the debugging messages.\n        this.name = 'ChatComponent';\n        // We will always define our component HTML selectors and classes this way so we only define\n        // once and we don't contaminate our logic with tags and other stuff.\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            PERSONABANNER: `[data-block_ai_chat-element='personabanner']`,\n            PERSONA_UPDATE_BUTTON: `[data-block_ai_chat-element='personaupdatebutton']`,\n        };/*\n        this.classes = {\n            BITTEN: `bitten`,\n        };*/\n        // If you need local attributes like ids os something it should be initialized here.\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Note in this case we want our stateReady to be async.\n     *\n     * @param {object} state the initial state\n     */\n    stateReady(state) {\n        console.log(state)\n        this.addEventListener(\n            this.getElement(this.selectors.PERSONA_UPDATE_BUTTON),\n            'click',\n            this._putPersonaListener\n        );\n        this._refreshMessages({element: state});\n        this._refreshPersona({element: state});\n    }\n\n    /**\n     * We want to update the person every time something in its state change. To do this we need\n     * to define a watcher.\n     *\n     * @returns {Array} of watchers\n     */\n    getWatchers() {\n        return [\n            {watch: `state.messages:updated`, handler: this._refreshMessages},\n            {watch: `state.currentPersona:updated`, handler: this._refreshPersona},\n        ];\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    _refreshMessages({element}) {\n        // We have a convenience method to locate elements inside the component.\n        console.log(element);\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    _refreshPersona({element}) {\n        // We have a convenience method to locate elements inside the component.\n        console.log(element)\n        console.log(element.currentPersona);\n        console.log('PERSONA WIRD REFRESHED')\n        console.log(this.getElement(this.selectors.PERSONABANNER))\n        this.getElement(this.selectors.PERSONABANNER).innerText = `userFacedText: ${element.currentPersona.userFacedText}`;\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n\n    _putPersonaListener() {\n        // We don't want to submit the form.\n        event.preventDefault();\n        // Get the selected person id.\n        console.log('Firing the event')\n        const persona = {\n            userid: 0,\n            name: \"new name\",\n            prompt: \"New prompt\",\n            userinfo: \"Das ist eine neue persona\",\n        };\n        this.reactive.dispatch('putPersona', 21, persona);\n    }\n}\n\nexport default ChatComponent;"],"names":["ChatComponent","BaseComponent","create","name","selectors","MESSAGES","PERSONABANNER","PERSONA_UPDATE_BUTTON","stateReady","state","console","log","addEventListener","this","getElement","_putPersonaListener","_refreshMessages","element","_refreshPersona","getWatchers","watch","handler","currentPersona","innerText","userFacedText","event","preventDefault","reactive","dispatch","userid","prompt","userinfo"],"mappings":"sLAEMA,sBAAsBC,wBAQxBC,cAESC,KAAO,qBAGPC,UAAY,CACbC,mDACAC,6DACAC,4EAeRC,WAAWC,OACPC,QAAQC,IAAIF,YACPG,iBACDC,KAAKC,WAAWD,KAAKT,UAAUG,uBAC/B,QACAM,KAAKE,0BAEJC,iBAAiB,CAACC,QAASR,aAC3BS,gBAAgB,CAACD,QAASR,QASnCU,oBACW,CACH,CAACC,+BAAiCC,QAASR,KAAKG,kBAChD,CAACI,qCAAuCC,QAASR,KAAKK,kBAa9DF,2BAAiBC,QAACA,cAEdP,QAAQC,IAAIM,SAahBC,2BAAgBD,QAACA,eAEbP,QAAQC,IAAIM,SACZP,QAAQC,IAAIM,QAAQK,gBACpBZ,QAAQC,IAAI,0BACZD,QAAQC,IAAIE,KAAKC,WAAWD,KAAKT,UAAUE,qBACtCQ,WAAWD,KAAKT,UAAUE,eAAeiB,mCAA8BN,QAAQK,eAAeE,eAKvGT,sBAEIU,MAAMC,iBAENhB,QAAQC,IAAI,yBAOPgB,SAASC,SAAS,aAAc,GANrB,CACZC,OAAQ,EACR1B,KAAM,WACN2B,OAAQ,aACRC,SAAU,4CAMP/B"}