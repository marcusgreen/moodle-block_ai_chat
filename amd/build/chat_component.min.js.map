{"version":3,"file":"chat_component.min.js","sources":["../src/chat_component.js"],"sourcesContent":["import {BaseComponent} from 'core/reactive';\nimport Templates from 'core/templates';\nimport * as helper from 'block_ai_chat/helper';\n\nclass ChatComponent extends BaseComponent {\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        // This is an optional name for the debugging messages.\n        this.name = 'ChatComponent';\n        // We will always define our component HTML selectors and classes this way so we only define\n        // once and we don't contaminate our logic with tags and other stuff.\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            PERSONABANNER: `[data-block_ai_chat-element='personabanner']`,\n            PERSONA_SELECT_DROPDOWN: `[data-block_ai_chat-element='personaselectdropdown']`,\n            INPUT_TEXTAREA: `[data-block_ai_chat-element='inputtextarea']`,\n            SUBMIT_BUTTON: `[data-block_ai_chat-element='submitbutton']`,\n            LOADING_SPINNER_MESSAGE: `[data-block_ai_chat-element='loadingspinner']`,\n            TEMPORARY_PROMPT_MESSAGE: `[data-block_ai_chat-element='temporaryprompt']`,\n        };/*\n        this.classes = {\n            BITTEN: `bitten`,\n        };*/\n        // If you need local attributes like ids os something it should be initialized here.\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Note in this case we want our stateReady to be async.\n     *\n     * @param {object} state the initial state\n     */\n    stateReady(state) {\n\n        console.log(state)\n        const personaDropdownContainer = this.getElement(this.selectors.PERSONA_SELECT_DROPDOWN);\n        this.reactive.state.personas.forEach((persona) => {\n            const optionElement = document.createElement('option');\n            optionElement.value = persona.id;\n            optionElement.text = persona.name;\n            personaDropdownContainer.appendChild(optionElement);\n        });\n        const personaBanner = this.getElement(this.selectors.PERSONABANNER);\n        personaBanner.innerText = `${this.reactive.state.personas.get(state.config.currentPersona).userinfo}`;\n        this.addEventListener(\n            this.getElement(this.selectors.PERSONA_SELECT_DROPDOWN),\n            'change',\n            this._selectCurrentPersonaListener\n        );\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        console.log(textarea)\n        const sendRequestButton = this.getElement(this.selectors.SUBMIT_BUTTON);\n        sendRequestButton.addEventListener('click', this._submitAiRequestListener.bind(this));\n        this._refreshPersona({element: state.config});\n    }\n\n    /**\n     * We want to update the person every time something in its state change. To do this we need\n     * to define a watcher.\n     *\n     * @returns {Array} of watchers\n     */\n    getWatchers() {\n        return [\n            {watch: `messages:created`, handler: this._addMessageToChatArea},\n            {watch: `messages:deleted`, handler: this._removeMessageFromChatArea},\n            {watch: `config.currentPersona:updated`, handler: this._refreshPersona},\n            {watch: `config.loadingState:updated`, handler: this._handleLoadingStateUpdated},\n        ];\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    async _addMessageToChatArea({element}) {\n        // We have a convenience method to locate elements inside the component.\n        console.log('MESSAGES WERDEN GERENDERT')\n        console.log(element);\n        // TODO Filter messages that do not belong to the current conversation\n\n        const templateData = {\n            id: element.id,\n            senderai: element.sender === 'ai',\n            content: element.content,\n            loading: element.hasOwnProperty('loading') ? element.loading : false,\n        };\n        const {html, js} = await Templates.renderForPromise('block_ai_chat/message', templateData);\n        Templates.appendNodeContents('.block_ai_chat-output', html, js);\n\n        // Add copy listener for question and reply.\n        helper.attachCopyListenerLast();\n\n        // Scroll the modal content to the bottom.\n        helper.scrollToBottom();\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n    _removeMessageFromChatArea({element}) {\n        // TODO Fetch component here instead of \"manual\" selector\n        this.getElement(`[data-block_ai_chat-messageid='${element.id}']`).remove();\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element (a person in this case)\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.element the person structure.\n     */\n    _refreshPersona({element}) {\n        // We have a convenience method to locate elements inside the component.\n        const newPersonaId = element.currentPersona;\n        console.log(newPersonaId);\n        console.log('PERSONA WIRD REFRESHED')\n        console.log(this.getElement(this.selectors.PERSONABANNER))\n        this.getElement(this.selectors.PERSONABANNER).innerText = `${this.reactive.state.personas.get(newPersonaId).userinfo}`;\n        //const target = this.getElement(this.selectors.MESSAGES, element.id);\n    }\n\n\n    _putPersonaListener() {\n        // We don't want to submit the form.\n        event.preventDefault();\n        // Get the selected person id.\n        console.log('Firing the event')\n        const persona = {\n            userid: 0,\n            name: \"new name\",\n            prompt: \"New prompt\",\n            userinfo: \"Das ist eine neue persona\",\n        };\n        this.reactive.dispatch('putPersona', 21, persona);\n    }\n\n    _selectCurrentPersonaListener() {\n        event.preventDefault();\n        this.reactive.dispatch('selectCurrentPersona', this.reactive.state.static.contextid, event.target.value);\n    }\n\n    _submitAiRequestListener() {\n        event.preventDefault();\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const prompt = textarea.value;\n        this.reactive.dispatch('submitAiRequest', prompt);\n    }\n\n    async _handleLoadingStateUpdated({element}) {\n\n        console.log(\"loading state updated\")\n        console.log(element.loadingState)\n\n        const loadingSpinnerMessage = {\n            'id': 'loadingspinner',\n            'sender': 'user',\n            'loading': true\n        };\n\n        const temporaryPromptMessage= {\n            'id': 'temporaryprompt',\n            'sender': 'user',\n            'content': this.getElement(this.selectors.INPUT_TEXTAREA).value,\n        };\n\n        if (element.loadingState) {\n            await this._addMessageToChatArea({element: temporaryPromptMessage});\n            await this._addMessageToChatArea({element: loadingSpinnerMessage});\n            this.getElement(this.selectors.INPUT_TEXTAREA).value = '';\n        } else {\n            this._removeMessageFromChatArea({element: temporaryPromptMessage});\n            this._removeMessageFromChatArea({element: loadingSpinnerMessage});\n        }\n    }\n\n}\n\nexport default ChatComponent;"],"names":["ChatComponent","BaseComponent","create","name","selectors","MESSAGES","PERSONABANNER","PERSONA_SELECT_DROPDOWN","INPUT_TEXTAREA","SUBMIT_BUTTON","LOADING_SPINNER_MESSAGE","TEMPORARY_PROMPT_MESSAGE","stateReady","state","console","log","personaDropdownContainer","this","getElement","reactive","personas","forEach","persona","optionElement","document","createElement","value","id","text","appendChild","innerText","get","config","currentPersona","userinfo","addEventListener","_selectCurrentPersonaListener","textarea","_submitAiRequestListener","bind","_refreshPersona","element","getWatchers","watch","handler","_addMessageToChatArea","_removeMessageFromChatArea","_handleLoadingStateUpdated","templateData","senderai","sender","content","loading","hasOwnProperty","html","js","Templates","renderForPromise","appendNodeContents","helper","attachCopyListenerLast","scrollToBottom","remove","newPersonaId","_putPersonaListener","event","preventDefault","dispatch","userid","prompt","static","contextid","target","loadingState","loadingSpinnerMessage","temporaryPromptMessage"],"mappings":"quCAIMA,sBAAsBC,wBAQxBC,cAESC,KAAO,qBAGPC,UAAY,CACbC,mDACAC,6DACAC,+EACAC,8DACAC,4DACAC,wEACAC,2EAeRC,WAAWC,OAEPC,QAAQC,IAAIF,aACNG,yBAA2BC,KAAKC,WAAWD,KAAKb,UAAUG,8BAC3DY,SAASN,MAAMO,SAASC,SAASC,gBAC5BC,cAAgBC,SAASC,cAAc,UAC7CF,cAAcG,MAAQJ,QAAQK,GAC9BJ,cAAcK,KAAON,QAAQnB,KAC7Ba,yBAAyBa,YAAYN,kBAEnBN,KAAKC,WAAWD,KAAKb,UAAUE,eACvCwB,oBAAeb,KAAKE,SAASN,MAAMO,SAASW,IAAIlB,MAAMmB,OAAOC,gBAAgBC,eACtFC,iBACDlB,KAAKC,WAAWD,KAAKb,UAAUG,yBAC/B,SACAU,KAAKmB,qCAEHC,SAAWpB,KAAKC,WAAWD,KAAKb,UAAUI,gBAChDM,QAAQC,IAAIsB,UACcpB,KAAKC,WAAWD,KAAKb,UAAUK,eACvC0B,iBAAiB,QAASlB,KAAKqB,yBAAyBC,KAAKtB,YAC1EuB,gBAAgB,CAACC,QAAS5B,MAAMmB,SASzCU,oBACW,CACH,CAACC,yBAA2BC,QAAS3B,KAAK4B,uBAC1C,CAACF,yBAA2BC,QAAS3B,KAAK6B,4BAC1C,CAACH,sCAAwCC,QAAS3B,KAAKuB,iBACvD,CAACG,oCAAsCC,QAAS3B,KAAK8B,mEAajCN,QAACA,cAEzB3B,QAAQC,IAAI,6BACZD,QAAQC,IAAI0B,eAGNO,aAAe,CACjBrB,GAAIc,QAAQd,GACZsB,SAA6B,OAAnBR,QAAQS,OAClBC,QAASV,QAAQU,QACjBC,UAASX,QAAQY,eAAe,YAAaZ,QAAQW,UAEnDE,KAACA,KAADC,GAAOA,UAAYC,mBAAUC,iBAAiB,wBAAyBT,iCACnEU,mBAAmB,wBAAyBJ,KAAMC,IAG5DI,OAAOC,yBAGPD,OAAOE,iBAIXf,sCAA2BL,QAACA,oBAEnBvB,oDAA6CuB,QAAQd,UAAQmC,SAYtEtB,2BAAgBC,QAACA,qBAEPsB,aAAetB,QAAQR,eAC7BnB,QAAQC,IAAIgD,cACZjD,QAAQC,IAAI,0BACZD,QAAQC,IAAIE,KAAKC,WAAWD,KAAKb,UAAUE,qBACtCY,WAAWD,KAAKb,UAAUE,eAAewB,oBAAeb,KAAKE,SAASN,MAAMO,SAASW,IAAIgC,cAAc7B,UAKhH8B,sBAEIC,MAAMC,iBAENpD,QAAQC,IAAI,yBAOPI,SAASgD,SAAS,aAAc,GANrB,CACZC,OAAQ,EACRjE,KAAM,WACNkE,OAAQ,aACRnC,SAAU,8BAKlBE,gCACI6B,MAAMC,sBACD/C,SAASgD,SAAS,uBAAwBlD,KAAKE,SAASN,MAAMyD,OAAOC,UAAWN,MAAMO,OAAO9C,OAGtGY,2BACI2B,MAAMC,uBAEAG,OADWpD,KAAKC,WAAWD,KAAKb,UAAUI,gBACxBkB,WACnBP,SAASgD,SAAS,kBAAmBE,oDAGb5B,QAACA,eAE9B3B,QAAQC,IAAI,yBACZD,QAAQC,IAAI0B,QAAQgC,oBAEdC,sBAAwB,IACpB,wBACI,gBACC,GAGTC,uBAAwB,IACpB,yBACI,eACC1D,KAAKC,WAAWD,KAAKb,UAAUI,gBAAgBkB,OAG1De,QAAQgC,oBACFxD,KAAK4B,sBAAsB,CAACJ,QAASkC,+BACrC1D,KAAK4B,sBAAsB,CAACJ,QAASiC,6BACtCxD,WAAWD,KAAKb,UAAUI,gBAAgBkB,MAAQ,UAElDoB,2BAA2B,CAACL,QAASkC,8BACrC7B,2BAA2B,CAACL,QAASiC,uCAMvC1E"}